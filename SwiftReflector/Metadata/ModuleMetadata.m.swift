//
//  ModuleMetadata.m.swift
//  SwiftReflector
//
//  Created by Krunoslav Zaher on 7/21/15.
//  Copyright Â© 2015 Krunoslav Zaher. All rights reserved.
//

import Foundation
import Cocoa

func makeSurePathIsSafe(path: String) throws {
    if path.hasPrefix("/") {
        precondition(path.hasPrefix(fileManager.currentDirectoryPath))
    }
    
    precondition(path.rangeOfString("..") == nil)

    if fileManager.fileExistsAtPath(path) {
        let contents = try NSString(contentsOfFile: path, encoding: NSUTF8StringEncoding)
        
        precondition(contents.hasPrefix("// Autogenerated "))
    }
}

class ModuleMetadata : ModuleMetadataType {
    
    var interfaceForTypeNamed: [String: InterfaceMetadata] = [:]
    
    init() {
    }
    
    func interfaceForType(type: Type) -> InterfaceMetadata? {
        return interfaceForTypeNamed[type.description]
    }

    func registerInterface(interface: InterfaceMetadata) {
        self.interfaceForTypeNamed[interface.type.description] = interface
    }
    
    func loadMetadata(metadataPath: String, attributes: [AnyObject]) {
        let metadataData = NSData(contentsOfFile: metadataPath)!
        
        let json = try! NSJSONSerialization.JSONObjectWithData(metadataData, options: NSJSONReadingOptions(rawValue: 0))
        
        let fileContents = try! Json.deserialize(json) as [SourceFile]
        
        var count = 0

        for fileContent in fileContents {
            for declaration in fileContent.declarations {
                switch declaration {
                case .Interface(let interfaceMetadata):
                    interfaceMetadata.file = fileContent
                    self.registerInterface(interfaceMetadata)
                    
                    for _ in interfaceMetadata.serializedAttributes {
                        let attribute = attributes[count]
                        interfaceMetadata.registerAttribute(attribute)
                        count++
                    }
                    
                    for p in interfaceMetadata.properties {
                        for _ in p.serializedAttributes {
                            let attribute = attributes[count]
                            p.registerAttribute(attribute)
                            count++
                        }
                    }
                default: break
                }
            }
        }
       
        precondition(count == attributes.count)
    }

    func generateMetadata() {
        let newInterfaces = self.interfaceForTypeNamed.values
            .flatMap { i -> [InterfaceMetadata] in
                print("\(i.type) -> attributes \(i.serializedAttributes)")
                return i.attributes.values
                    .filter { ($0 as? MetadataGeneratorType) != nil }
                    .flatMap { a -> [InterfaceMetadata] in
                        return (a as! MetadataGeneratorType).generateInterfaces(i, metadata: self)
                    }
            }
        for interface in newInterfaces {
            self.registerInterface(interface)
        }
    }
    
    func generateSourceCode() {
        var generatingAttributesForPaths: [String: [(CodeGeneratorType, InterfaceMetadata)]] = [:]
        var modulesForPaths: [String: [String]] = [:]
        
        for interface in self.interfaceForTypeNamed.values {
            for attribute in interface.attributes.values {
                if let codeGenerator = attribute as? CodeGeneratorType {
                    let generatePath = codeGenerator.pathForGeneratedSourceCode(interface, metadata: self)
                
                    try! makeSurePathIsSafe(generatePath)
                    
                    if generatingAttributesForPaths[generatePath] == nil {
                        generatingAttributesForPaths[generatePath] = []
                    }
                    
                    generatingAttributesForPaths[generatePath]!.append(codeGenerator, interface)
                    
                    if modulesForPaths[generatePath] == nil {
                        modulesForPaths[generatePath] = []
                    }
                    
                    for declaration in interface.file.declarations {
                        switch declaration {
                        case .Import(let module):
                            if !modulesForPaths[generatePath]!.contains(module) {
                                modulesForPaths[generatePath]?.append(module)
                            }
                        default: break
                        }
                    }
                }
            }
            
        }
        
        for (generatePath, pairs) in generatingAttributesForPaths {
            if !fileManager.fileExistsAtPath(generatePath) {
                fileManager.createFileAtPath(generatePath, contents: nil, attributes: nil)
            }
            
            let writeHandle = try! NSFileHandle(forWritingToURL: NSURL(string: generatePath)!)
            writeHandle.writeln("// Autogenerated `SwiftReflector` @ \(NSDate())")
            writeHandle.writeln("")
            for module in modulesForPaths[generatePath] ?? [] {
                writeHandle.writeln("import \(module)")
            }
            writeHandle.writeln("")
            
            for (codeGenerator, interfaceMetadata) in pairs {
                writeHandle.writeln("// \(interfaceMetadata.type)")
                writeHandle.writeln("")
                codeGenerator.write(interfaceMetadata, metadata: self, file: writeHandle)
                writeHandle.writeln("")
            }
            writeHandle.writeln("")
            
            writeHandle.truncateFileAtOffset(writeHandle.offsetInFile)
            
            writeHandle.closeFile()
        }
    }
    
    class func generate(metadataPath: String, attributes: [AnyObject]) -> ModuleMetadata {
        
        let moduleMetadata = ModuleMetadata()
        
        moduleMetadata.loadMetadata(metadataPath, attributes: attributes)
        moduleMetadata.generateMetadata()
        moduleMetadata.generateSourceCode()
        
        return moduleMetadata
    }
}